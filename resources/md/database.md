## Configuring the Database

Luminus defaults to using [Ragtime](https://github.com/weavejester/ragtime) for database migrations and
[Yesql](https://github.com/krisajenkins/yesql) for database interaction. The migrations and a default connection will be setup when using a database profile such as `+postgres`.

### Configuring Migrations

In order to configure Ragtime we first have to set the connection string for our database in `project.clj`.

```clojure
:ragtime {:migrations ragtime.sql.files/migrations
          :database "jdbc:postgresql://localhost/example_db?user=root"}
```

Then we can create SQL scripts to migrate the database schema, and to roll it back. These are applied in alphanumeric order, conventionally the current date is used to prefix the filename. The files are expected to be present under the `migration` folder.

```
migrations/201501155317-add-users-table.down.sql
migrations/201501155317-add-users-table.up.sql
```

With the above setup we can run the migrations as follows:

```
lein ragtime migrate
```

Applied migration can then be rolled back with:

```
lein ragtime rollback
```

Please refer to the [Database Migrations](/docs/migrations.md) section for more details.

### Setting up the database connection

The first thing we'll need to do is to define our database connection, this can be done by providing a map of connection parameters:

```clojure
(def db-spec {:subprotocol "postgresql"
              :subname "//localhost/my_website"
              :user "admin"
              :password "admin"})
```

Another approach is to specify the JNDI name for a connection managed by the application server:

```clojure
(def db-spec {:name "jdbc/myDatasource"})
```

This can be useful if you have multiple environments in which the application runs in. For example,
if you have dev/staging/production servers, you can point the JNDI connection to their respective databases.
The application will pick up the connection from the environment when it loads, which means that you can
safely deploy the same code in each environment.

Finally, you can provide a JDBC data source, which you configure manually:

```clojure
(def db-spec
  {:datasource
    (doto (new PGPoolingDataSource)
     (.setServerName     "localhost")
     (.setDatabaseName   "my_website")
     (.setUser           "admin")
     (.setPassword       "admin")
     (.setMaxConnections 10))})
```

This option is useful if you wish to specify any driver specific parameters directly.

### Working with Yesql

Yesql uses plain SQL to define the queries. The comments are used to supply the function name and a doc string for each query.

Conventionally the queries should be placed in the `resources/sql/queries.sql` file.
The format for the file is `(<name tag> [docstring comments] <the query>)*`.
Let's take a look at a simple query below:

```sql
--name: create-user!
-- creates a new user record
INSERT INTO users
(id, first_name, last_name, email, pass)
VALUES (:id, :first_name, :last_name, :email, :pass)
```

As we can see the query is written using plain SQL and the parameters are denoted by prefixing the parameter name with a colon. We can now refer to the query by calling the `defqueries` macro.

```clojure
(ns myapp.db.core
  (:require [yesql.core :refer [defqueries]]))

(defqueries "some/where/queryfile.sql")
```

Once `defqueries` is run the query we defined above will be mapped to `myapp.db.core/create-user!` function.
The functions generated by `defqueries` must be passed a DB specification as the first parameter.
The parameters are passed in using a map with the keys that match the parameter names specified.

```clojure
(create-user!
  db-spec
  {:id "user1"
   :first_name "Bob"
   :last-name "Bobberton"
   :email "bob.bobberton@mail.com"
   :pass "verysecret"})
```

Alternatively, we can pass the DB spec directly to `defqueries` and it will be used as the default connection if none is supplied.

```clojure
(defqueries "sql/queries.sql" {:connection db-spec})

(create-user!
  {:id "user1"
   :first_name "Bob"
   :last-name "Bobberton"
   :email "bob.bobberton@mail.com"
   :pass "verysecret"})
```

See the [official documentation](https://github.com/krisajenkins/yesql/tree/devel) for more details.

### SQL Korma

>[Korma is a domain specific language for Clojure that takes the pain out of working with your favorite RDBMS. Built for speed and designed for flexibility, Korma provides a simple and intuitive interface to your data that won't leave a bad taste in your mouth.](http://sqlkorma.com/)


Adding Korma support to an existing project is rather simple as well. You will first need to add the Korma dependency
to you `project.clj`:

```clojure
[korma "0.4.0"]
```

We'll have to add a reference to `korma.db` in order to start using Korma.

```clojure
(ns myapp.db.core
  (:use korma.core
        [korma.db :only (defdb)]))
```


Korma requires us to wrap the `db-spec` using `defdb` as follows:

```clojure
(defdb db db-spec)
```

This will create a connection pool for your db spec using the [c3p0](http://sourceforge.net/projects/c3p0/) library.
Note that the last created pool is set as the default for all queries.

Korma uses entities to represent SQL tables. The entities represent the core building blocks of your queries.
These entities are created by using `defentity` macro:

```clojure
(defentity users)
```

Using the users entity we can rewrite our query to create a user as follows:

```clojure
(defn create-user [user]
  (insert users
          (values user)))
```

The get user query would then be rewritten as:

```clojure
(defn get-user [id]
  (first (select users
                 (where {:id id})
                 (limit 1))))
```

For further documentation on Korma and its features please refer to the [official documentation page](http://sqlkorma.com/docs).


